1.作用域(Scope)
	***是一个存储应用数据模型的对象
	***为表达式提供了一个执行上下文
	***作用域的层级结构对应于DOM树结构
	***作用域可以监听表达式的变化并传播事件

2.作用域有什么
	1):作用域提供了($watch)方法监听数据模型的变化。
	2):作用域提供了($watch)方法把不是由angular触发的数据模型的改变引入angular的控制范围内
	(如控制器，服务，及angular事件处理器等)。
	3):作用域提供了基于原型链继承其父作用域属性的机制，就算是嵌套于独立的应用组件中的作用域也可以
	访问共享的数据模型(这个涉及到指令间嵌套时作用域的几种模式)
	4):作用域提供了表达式的执行环境，比如像{{username}}这个表达式，必须得是在一个拥有属性这个属性
	的作用域中执行才会有意义，也就是说，作用域中可能会像这样scope.username或是$scope.username,至于
	有没有$符号，看你是在哪里访问作用域了。

3.作用域作为数据模型使用
	作用域是web应用的控制器和视图之间的粘接剂。在angular中，最直观的表现是：在自定义指令中，处在模板的
	链接阶段时，指令(directive)会设置一个$watch函数监听着作用域中各表达式(注：这个过程是隐式的)。这个
	$watch允许指令在作用域中的属性变化时收到通知，进而让指令能够根据这个改变来对DOM进行重新渲染，以便
	更新已改变的属性值(注：属性值就是scope对象中的属性，也就是数据模型)。
	***作用域(scope)对象以及其属性是视图渲染的唯一数据来源。

4.作用域分层结构
	如上所说，作用域的结构对应于DOM结构，那么最顶层，和DOM树有根节点一样，每个angular应用有且仅有一个
	root scope，当然拉，子级作用域就和DOM树的子节点一样，可以有多个。
	应用可以拥有多个作用域，比如指令会创建子作用域(至于指令创建的作用域是有多种类型的，请看文档)。一般
	情况下，当新的作用域被创建时，它是以嵌入在父级作用域的子级的形式被创建的，这样就形成了与其所关联的
	DOM树相对应的一个作用域的树结构。
	***作用域的层级继承是基于原型链的继承，所以在下面的列子中会看到，读属性时会一直往上溯源，直到有未知。
	作用域的分层的一个简单列子是，假设现在HTML视图中有一个表达式{{name}}，正如上面解释过，angular需要
	经历取值和计算两个阶段才能最终在视图渲染结果。那么这个取值的阶段，其实就是根据作用域的这个层级结构
	(或树状结构)来进行的。(父作用域和子作用域取值<层级关系>)
	》》》》》》》<li ng-repeat="task in tasks"></li>,ng-repeat指令会创建不同的子作用域。

5.从DOM中抓取作用域(程序调试)
	作用域对象是与指令或控制器等angular元素所在的DOM节点相关联的，也就是说，其实DOM节点上是可以
	抓取到作用域这个对象

6.基于作用域的事件传播
	作用域可以像DOM节点一样，进行事件的传播。主要是有两个方法：
	1):broadcasted:从父级作用域广播至子级scope
	2):emitted:从子级作用域往上发射到父级作用域
	①$emit和%$broadcast是被直接写在html模板中的，而不是写在控制器的javaScript代码中，因为两个方法是
	直接在$scope中就有的。
	②同一个控制器EventController被用在了三个不同的DOM节点中(这是为了省事，通常不这样写的)
	③上面的事件无非就是点击两个按钮，分别触发广播/冒泡(发射)事件，然后再各节点设置监听，这里只要用
	$scope.$on()方法，就可以进行监听了。***如果在指令中，可能就是scope.$on()

7.scope生命周期拆解
	相信看了上面一段话，没理解得还是很多人，因为标题虽说是讲作用域得生命周期，但是一上来就跟我讲的是
	关于angular得执行上下文，怎么也没联系到一块。说实话，翻译这段，真心有点要命得感觉。当然把它拆分
	成多个步骤来看，相信会更清晰，因为下面我们是真要讲作用域得生命周期，让我们来过一遍。
	①创建期
	root scope是在应用程序启动时由$injector创建的，另外，在指令的模板链接阶段，指令会创建一些新的子级scope
	②注册$watch
	在模板链接阶段，指令会往作用域中注册监听器(watch)，而且不止一个。这些$watch用来检测数据模型的更新
	并将更新值传给DOM。
	③数据模型变化
	正如上面一节所提到的，要想让数据模型的变化能够很好的被angular检测，需要让它们在scope.$apply()里发生。
	当然，对于angular本身的API来讲无论是在控制器中做同步操作，还是通过$http或者$timeout做的非同步操作，
	抑或是angular的服务中，是没有必要手动去将数据模型变化的操作放在$apply()中去的，因为angular已经隐式
	的为我们做了这一点。
	④数据模型变化检测
	在把数据变化$apply进来之后，angular开始进入$digest轮循(就是调用$digest()方法)，首先是rootscope进入
	$digest，然后由其把各个监听表达式或是函数的任务传播分配给所有的子级作用域，那样各个作用域就各司其职了，
	如果监听到自己负责的数据模型有变化，马上就调用$watch。
	⑤销毁作用域
	当子级作用域不再需要的时候，这时候创建它们的就会负责把它们回收或者销毁(注：比如在指令中，创建是隐式的，
	销毁不但可以是隐式的，也可以是显式的，如scope.$destroy())。销毁是通过scope.$destroy()这个方法。销毁
	之后，$digest()方法就不会继续往子级作用域传播了，这样就可以让垃圾回收系统把这一个作用域用来存放
	数据模型的内存给回收利用了。
	


8.作用域得生命周期(作用域得执行上下文)
	上面的过程中，如果一切都发生在angular的执行上下文的话，那相安无事，angular能够知道数据模型发生的改变；
	但是如果浏览器的控制权跑到原生的javaScript中去时，那么应用执行的上下文就发生在angular的上下文之外了，
	这样就导致angular无法知晓数据模型的任何改变。想要让angular重新掌权并知晓正在发生的数据模型的变化的话，
	那就需要通过使用$apply方法让上下文执行环境重新进入到angular的上下文中。(用法：$scope.$apply())

9.作用域和指令
	在编译(或说解析)阶段，编译器在html解析器解析页面遇到非传统的或是自己不能识别的标签或别的表达式时，
	angular编译器就将这些html解析器不懂得东西(其实就是指令)在当前得DOM环境下解析出来。通常，指令分为两种，
	一种就是我们常说得指令，另外一种就是我们通常叫它angular表达式得双括号形式，具体如下：
	①监测型指令，像双大括号表达式{{expression}}。这种类型得指令需要在$watch()方法中注册一个监听处理器
	(隐式还是显式得需要看执行上下文)，老监听控制器或者时别得操作引起的表达式改变，进而来更新视图。
	②监听型指令，像ng-click，这种是在html标签属性中直接写好当ng-click发生时调用什么处理器，当DOM监听到
	ng-click被触发时，这个指令就会通过$apply()方法执行相关的表达式操作或是别的操作
	综上，无论是那种类型的指令，当外部事件(可能是用户输入，定时器，ajax等)发生时，相关的表达式必须要通过
	$apply()作用于相应的作用域，这样所有的监听器才能被正确更新，然后进行后续的相关操作。
	

10.可以创建作用域的指令
	大多数情况下，指令和作用域相互作用，但并不创建作用域的新实例。但是，有一些特殊的指令，如ng-controller
	和ng-repeat等，则会创建新的下级作用域，并且把这个新创建的作用域和相应的DOM元素相关联。如前面说过的
	DOM元素抓取作用域的方式,就是调用angular.element(aDomElement).scope()方法。

11.作用域与控制器
	作用域和控制器的交互大概有以下几种情况：
	①控制器通过作用域对模板暴露一些方法供其调用。
	②控制器中定义的一些方法(行为或操作逻辑)可以改变注册在作用域下的数据模型(也就是作用域的属性)。
	③控制器在某些场合可能需要设置监听器来监听作用域中的数据模型(model)。这些监听器在控制器的相关
	方法被调用时立即执行。











	